*2421. Number of Good Paths

Solution :

class Solution {
    HashMap<Integer, ArrayList<Integer>> graph = new HashMap();
    TreeMap<Integer, ArrayList<Integer>> valMap = new TreeMap();
    public int numberOfGoodPaths(int[] vals, int[][] edges) {
        if(vals.length <= 1) return vals.length;
        
        // we make an adjecency list for nodes smaller or equal to val of curr node
        for(int i = 0; i < edges.length; i++) {
            if(vals[edges[i][0]] >= vals[edges[i][1]]) {
                ArrayList<Integer> list = graph.getOrDefault(edges[i][0], new ArrayList());
                list.add(edges[i][1]);
                graph.put(edges[i][0], list);
            }
            
            if(vals[edges[i][0]] <= vals[edges[i][1]]) {
                ArrayList<Integer> list = graph.getOrDefault(edges[i][1], new ArrayList());
                list.add(edges[i][0]);
                graph.put(edges[i][1], list);
            }
        }
        
        // we make an ordered map for mapping values to corresponding nodes
        for(int i = 0; i < vals.length; i++) {
            ArrayList<Integer> sameValNodes = valMap.getOrDefault(vals[i], new ArrayList());
            sameValNodes.add(i);
            valMap.put(vals[i], sameValNodes);
        }
        
        // using union-find
        UnionFind uf = new UnionFind(vals.length);
        
        // single nodes with path containing themselves alone
        int sum = vals.length;
        for(int val : valMap.keySet()) {
            // for all the nodes with same value, join them with their corresponding adjacent nodes in the graph
            // note this graph contains only edges to smaller or equal nodes
            for(int node : valMap.get(val)) {
                // get each node's adj nodes
                if(!graph.containsKey(node)) continue;
                for(int nbrNode : graph.get(node)) {
                    uf.union(node, nbrNode);
                }
            }
            
            // try finding the number of connected same value nodes in the union'd component
            HashMap<Integer, Integer> connected = new HashMap<>();
            for(int node : valMap.get(val)) {
                if(!graph.containsKey(node)) continue;
                int pNode = uf.find(node);
                connected.put(pNode, connected.getOrDefault(pNode, 0) + 1);
            }
            
            // we are trying to find all combinations of nodes which are connected and adding it to sum
            for(int size : connected.values())
                sum += (size * (size - 1))/2;
        }

        return sum;
    }
    
    
}

// union-find .. with rank & path compression
class UnionFind {
    private int[][] dSet;
    
    public UnionFind(int len) {
        dSet = new int[len][2];
        for(int i = 0; i < len; i++){
            dSet[i][0] = -1;
            dSet[i][1] = 0;
        }
    }
    
    public int find(int a) {
        if(dSet[a][0] == -1)
            return a;
        int temp = find(dSet[a][0]);
        dSet[a][0] = temp;
        return temp;
    }
    
    public boolean union(int a, int b) {
        int absP1 = find(a);
        int absP2 = find(b);

        if(absP1 == absP2) return false;
        
        if(dSet[absP1][1] < dSet[absP2][1]) {
            // set parent of smaller set to abs parent of larger set
            dSet[absP1][0] = absP2;
            // rank doesnt change here
        } else if(dSet[absP1][1] > dSet[absP2][1]) {
            dSet[absP2][0] = absP1;
        } else {
            dSet[absP1][0] = absP2;
            dSet[absP1][1] += 1;
        }
        return true;
    }
}